# -*- coding: utf-8 -*-
# __author__ = 'guoquan'

from biocluster.iofile import File
from collections import defaultdict
import re
import subprocess
from biocluster.config import Config
import os
from biocluster.core.exceptions import FileError
from Bio import SeqIO

class FastaFile(File):
    def __init__(self):
        super(FastaFile, self).__init__()
        self.seqstat_path = os.path.join(Config().SOFTWARE_DIR, "bioinfo/seq/biosquid_1.9g+cvs20050121/bin/seqstat")
        self._seq_ids = []
        self._seq_obj = []
        self._seq_id_len_dic = {}
        self.seq_type = ''

    def get_info(self):
        super(FastaFile, self).get_info()
        seqinfo = self.get_seq_info()
        self.set_property("file_format", seqinfo[0])
        self.set_property("seq_type", seqinfo[1])
        self.set_property("seq_number", seqinfo[2])
        self.set_property("bases", seqinfo[3])
        self.set_property("longest", seqinfo[4])
        self.set_property("shortest", seqinfo[5])

    def check(self):
        self.get_info()
        if super(FastaFile, self).check():
            if self.prop['file_format'] != 'FASTA':
                raise FileError("file format error")
            if self.prop["seq_number"] < 1:
                raise FileError("should contain at least one sequence")
        return True


    def ncbi_blast_tool_check(self):
        if self.check():
            if self.prop['seq_type'] not in {"DNA", "Protein"}:
                raise FileError("this type of Fasta is not supported for blast alignment")
        return True


    def get_seq_info(self):
        try:
            if os.path.getsize(self.prop['path']) == 0:
                return "FASTA", "DNA", "0", "0", "0", "0"
            else:
                subpro = subprocess.check_output(self.seqstat_path + " " + self.prop['path'], shell=True)
                result = subpro.split('\n')
                fformat = re.split(r':\s+', result[5])[1]
                seq_type = re.split(r':\s+', result[6])[1]
                seq_number = re.split(r':\s+', result[7])[1]
                bases = re.split(r':\s+', result[8])[1]
                shortest = re.split(r':\s+', result[9])[1]
                longest = re.split(r':\s+', result[10])[1]
                # print (fformat, seq_type, seq_number, bases, longest, shortest)
                return fformat, seq_type, seq_number, bases, longest, shortest
        except subprocess.CalledProcessError:
            raise FileError("an error occurred with seqstat")

    def get_all_seq_name(self):
        seq_name = defaultdict(int)
        for seq in SeqIO.parse(self.prop["path"], "fasta"):
            seq_name[seq.id] += 1
        dup_list = list()
        for k in seq_name.iterkeys():
            if seq_name[k] > 1:
                dup_list.append(k)
            if len(dup_list) > 0:
                str_ = "; ".join(dup_list)
                raise FileError("{} is repeated in the input fasta file".format(str_))
        return seq_name

    def check_trinity(self):
        with open(self.path, 'r') as f:
            check_num = 10
            for i in f:
                if check_num == 0:
                    break
                if i[0] == '>':
                    check_num -= 1
                    if i.startswith('>TRINITY_'):
                        pass
                    else:
                        raise FileError('this file is not generated by trinity')
        return True


    def get_contig_len(self):
        for seq in SeqIO.parse(self.prop["path"], "fasta"):
            self._seq_id_len_dic[seq.id] =int(len(seq.seq))
        return self._seq_id_len_dic

    def choose_seq_by_list(self, choose_list, out, mode="w"):
        '''
        根据id list筛选fasta文件
        '''
        seq_records = SeqIO.parse(self.path, 'fasta')
        choosed_list = []
        with open(out, mode) as fa_o:
            for seq_record in seq_records:
                seq_seq = seq_record.seq
                seq_name = seq_record.name
                if seq_name in choose_list:
                    choosed_list.append(seq_name)
                    fa_o.write('>{}\n{}\n'.format(seq_name, seq_seq))
        return choosed_list

    def split_single_seq(self, output_dir):
        if not os.path.exists(output_dir):
            os.mkdir(output_dir)
        if self.check():
            try:
                seq_records = SeqIO.parse(self.path, 'fasta')
                for seq_record in seq_records:
                    seq_seq = seq_record.seq
                    seq_name = seq_record.name
                    line = '>{}\n{}\n'.format(seq_name, seq_seq)
                    open(os.path.join(output_dir, seq_name + '.fa'), 'w').write(line)
            except Exception:
                raise FileError("get split fa to single seqs failed")

    def split(self, output, chunk=10000):
        s, n = 1, 0
        wf = open("%s/%s.fa" % (output, s), 'w')
        with open(self.prop['path'], 'r') as f:
            while 1:
                line = f.readline()
                if not line:
                    wf.close()
                    break
                re_id = re.compile(r'^>(\S+)')
                m_id = re_id.match(line)
                if m_id is not None:
                    n += 1
                    if n == chunk + 1:
                        wf.close()
                        s += 1
                        n = 0
                        wf = open("%s/%s\.fa" % (output, s), 'w')
                wf.write(line)

    def merge_all_seq(self, file_name):
        if self.check():
            try:
                with open (file_name+'.fasta','w') as wf:
                    wf.write('>'+os.path.basename(file_name)+'\n')
                    for seq in SeqIO.parse(self.prop['path'], 'fasta'):
                        wf.write(str(seq.seq))
            except Exception:
                raise FileError("merge seqs failed")

    def merge_fasta(self, add_fasta, out_fasta):
        with open(out_fasta, 'w') as wf:
            for seq in SeqIO.parse(self.prop['path'], 'fasta'):
                seq_seq = seq.seq
                seq_name = seq.name
                line = '>{}\n{}\n'.format(seq_name, seq_seq)
                wf.write(line)
            for seq in SeqIO.parse(add_fasta, 'fasta'):
                seq_seq = seq.seq
                seq_name = seq.name
                line = '>{}\n{}\n'.format(seq_name, seq_seq)
                wf.write(line)

    def get_list_file(self, list_file):
        with open(list_file, 'w') as wf:
            for seq in SeqIO.parse(self.prop['path'], 'fasta'):
                wf.write("{}\n".format(seq.name))
